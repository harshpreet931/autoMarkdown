import { ParsedProject, FileInfo, ProjectStructure, ConversionOptions } from './types';

export class MarkdownConverter {
  private options: ConversionOptions;

  constructor(options: ConversionOptions = {}) {
    this.options = options;
  }

  convertToMarkdown(project: ParsedProject): string {
    const sections: string[] = [];

    // Header
    sections.push(this.generateHeader(project));

    // Table of Contents
    sections.push(this.generateTableOfContents(project));

    // Project Summary
    sections.push(this.generateProjectSummary(project));

    // Project Structure
    sections.push(this.generateProjectStructure(project.structure));

    // File Contents
    sections.push(this.generateFileContents(project.files));

    // Footer
    sections.push(this.generateFooter());

    return sections.join('\n\n');
  }

  private generateHeader(project: ParsedProject): string {
    const projectName = project.structure.name;
    return `# ${projectName} - Codebase Documentation

> Generated by autoMarkdown - Intelligent codebase to markdown converter

---`;
  }

  private generateTableOfContents(project: ParsedProject): string {
    const sections = [
      '## Table of Contents',
      '',
      '- [Project Summary](#project-summary)',
      '- [Project Structure](#project-structure)',
      '- [File Contents](#file-contents)'
    ];

    // Add file links
    project.files.forEach((file, index) => {
      const sanitizedPath = file.path.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
      sections.push(`  - [${file.path}](#file-${index + 1}-${sanitizedPath})`);
    });

    return sections.join('\n');
  }

  private generateProjectSummary(project: ParsedProject): string {
    const languages = [...new Set(project.files.map(f => f.language))];
    const totalSize = project.files.reduce((sum, f) => sum + f.size, 0);
    
    return `## Project Summary

${project.summary}

### Key Statistics
- **Total Files**: ${project.files.length}
- **Languages**: ${languages.join(', ')}
- **Total Size**: ${(totalSize / 1024).toFixed(2)} KB
- **Most Important Files**: ${project.files.slice(0, 5).map(f => f.path).join(', ')}`;
  }

  private generateProjectStructure(structure: ProjectStructure, level: number = 0): string {
    if (level === 0) {
      return `## Project Structure

\`\`\`
${this.renderStructureTree(structure, 0)}
\`\`\``;
    }
    
    return this.renderStructureTree(structure, level);
  }

  private renderStructureTree(structure: ProjectStructure, level: number): string {
    const indent = '  '.repeat(level);
    const icon = structure.type === 'directory' ? '├──' : '├──';
    let result = `${indent}${icon} ${structure.name}\n`;

    if (structure.children) {
      structure.children.forEach(child => {
        result += this.renderStructureTree(child, level + 1);
      });
    }

    return result;
  }

  private generateFileContents(files: FileInfo[]): string {
    const sections = ['## File Contents'];

    files.forEach((file, index) => {
      const sanitizedPath = file.path.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
      const fileSection = [
        `### File ${index + 1}: \`${file.path}\``,
        `<a id="file-${index + 1}-${sanitizedPath}"></a>`,
        '',
        this.generateFileMetadata(file),
        '',
        '```' + file.language,
        file.content,
        '```'
      ];

      sections.push(fileSection.join('\n'));
    });

    return sections.join('\n\n');
  }

  private generateFileMetadata(file: FileInfo): string {
    if (!this.options.includeMetadata) {
      return '';
    }

    return `**Language**: ${file.language} | **Size**: ${file.size} bytes | **Importance**: ${file.importance.toFixed(1)}`;
  }

  private generateFooter(): string {
    const timestamp = new Date().toISOString();
    return `---

*Documentation generated on ${timestamp} by [autoMarkdown](https://github.com/harshpreet931/autoMarkdown)*

**Tips for LLM Processing:**
- This markdown contains the complete codebase structure and content
- Files are ordered by importance (most important first)
- Use the table of contents for navigation
- Each file includes metadata for context
- The project structure shows the overall organization`;
  }

  convertToJson(project: ParsedProject): string {
    return JSON.stringify(project, null, 2);
  }
}